# IP3 - Ansible Configuration Management

## Overview

This project uses Ansible to automate the deployment of the YOLO e-commerce application, a full-stack MERN (MongoDB, Express, React, Node.js) application. The deployment is orchestrated using Ansible playbooks and roles to ensure a consistent and reproducible deployment process.

---

## Configuration Files

### hosts

```
# This is an example Ansible inventory file.
# The hosts below are grouped under the 'all' group,
# which is the default group for all hosts in the inventory.

[all]
ansible_host=127.0.0.1 # This host is the local machine.
port=2222 # This is the SSH port for the local machine.
```

The `hosts` file is the Ansible inventory file that defines the target machines for deployment. In this setup:
- **`[all]`**: Defines a group containing all managed hosts
- **`ansible_host=127.0.0.1`**: Targets the localhost (Vagrant VM)
- **`port=2222`**: Specifies the SSH port forwarded by Vagrant

---

### ansible.cfg

```cfg
# This is the main Ansible configuration file.
# It defines global settings for all Ansible runs.

[defaults]
# This specifies the inventory file to use for your hosts.
# It tells Ansible where to find the list of managed nodes.
inventory = hosts

# This is the default user that Ansible will use to connect to remote hosts.
remote_user = vagrant

# This is the path to the SSH private key used for authentication.
# This key is typically generated by Vagrant for its virtual machines.
private_key_file = .vagrant/machines/default/virtualbox/private_key

# This specifies the directory where Ansible will look for roles.
roles_path = ./ansible/roles

# This setting disables host key checking for new connections.
# It's useful for development environments like Vagrant, but
# it's recommended to enable this for production environments.
host_key_checking = False
```

The `ansible.cfg` file provides global configuration for Ansible:
- **`inventory`**: Points to the `hosts` file containing target machines
- **`remote_user`**: Specifies the user account for SSH connections (vagrant user)
- **`private_key_file`**: Path to the SSH private key for authentication
- **`roles_path`**: Directory where Ansible looks for roles
- **`host_key_checking`**: Disabled for development convenience

---

## Project Structure

### Folder and File Structure Explanation

- **`ansible/`**: This directory contains all the Ansible-related files, including roles and variables.
  - **`group_vars/`**: Contains variables that apply to groups of hosts
    - **`all.yml`**: Global variables available to all hosts
  - **`secrets.yml`**: Ansible Vault file for storing sensitive information
  - **`roles/`**: This directory holds reusable Ansible roles. Each role is a self-contained unit of automation that is included in a playbook.
    - **`backend_deployment/`**: This role is responsible for deploying the application's backend (Express API and MongoDB database).
    - **`clone_repo/`**: This role handles cloning the application's source code from the GitHub repository onto the target server.
    - **`frontend_deployment/`**: This role is dedicated to deploying the application's frontend (React application).
    - **`install_docker/`**: This role installs and configures Docker and Docker Python SDK on the target hosts.
    - **`install_git/`**: This role installs the Git version control system on the target hosts. It's a prerequisite for the `clone_repo` role.
    - **`network_deployment/`**: This role manages Docker network configurations to enable inter-container communication.
- **`backend/`**: This folder contains the source code for the application's backend (Node.js/Express API).
- **`client/`**: This folder contains the source code for the application's frontend (React application).
- **`.gitignore`**: This file specifies intentionally untracked files that Git should ignore. It helps keep the repository clean by excluding build artifacts, sensitive information, and editor-specific files.
- **`ansible.cfg`**: This is the global configuration file for Ansible. It defines various settings like the inventory file location, the default remote user, and SSH settings.
- **`Docker-compose.yaml`**: This file is used to define and run multi-container Docker applications. It specifies the services, networks, and volumes for the application, making it easy to deploy the entire stack with a single command.
- **`EXPLANATION.md`**: Documentation explaining the Docker and Docker Compose setup for the project.
- **`EXPLANATION1.md`**: This file - Documentation explaining the Ansible configuration management setup.
- **`hosts`**: This is the Ansible inventory file. It lists the managed nodes and organizes them into groups. This is where you define the target machines for your Ansible playbook.
- **`playbook.yaml`**: This is the main Ansible playbook. It orchestrates the entire deployment process by calling the roles in a specific order to build and deploy the application.
- **`README.md`**: Project documentation with setup instructions and usage guide.
- **`Vagrantfile`**: This file is used by Vagrant to define and configure virtual machines. It specifies the base box, network settings, and provisioners to create a consistent, reproducible development environment.

---

## Ansible Playbook (`playbook.yaml`)

```yaml
- name: Deploy YOLO on VM using Ansible
  hosts: all
  become: yes
  vars_files:
    - ansible/secrets.yml

  roles:
    - install_docker
    - install_git
    - clone_repo
    - network_deployment
    - backend_deployment
    - frontend_deployment
```

### Playbook Structure Explanation

- **`name`**: Descriptive name for the playbook run
- **`hosts: all`**: This line specifies that the playbook will run on all hosts defined in our `hosts` inventory file.
- **`become: yes`**: This tells Ansible to use privilege escalation (`sudo`) to run tasks with elevated permissions. This is necessary for system-level changes like installing software or configuring services.
- **`vars_files`**: This section loads variables from external files. The `ansible/secrets.yml` file contains sensitive information (can be encrypted with Ansible Vault).
- **`roles:`**: This section lists the Ansible roles that will be executed. The order in which they are listed is crucial, as Ansible executes tasks sequentially from top to bottom.

---

## Roles

This project uses Ansible to automate the deployment of a full-stack application using a roles-based architecture.

### Explanation of Role Execution Order

The order of the roles in this playbook is carefully structured to ensure all dependencies are met before a subsequent step is attempted. A playbook runs sequentially, meaning one role's completion is a prerequisite for the next.

#### 1. **`install_docker`**

- **Function**: This role is placed first because our services (backend, frontend, MongoDB) will be deployed using Docker containers. Docker needs to be installed and configured on the target servers before any container-related tasks can be performed.
- **Key Tasks**:
  - Updates apt cache
  - Installs prerequisites (apt-transport-https, ca-certificates, curl, gnupg, lsb-release)
  - Adds Docker GPG key and repository
  - Installs Docker CE
  - Installs Docker Python SDK (required for Ansible's docker modules)
  - Starts and enables Docker service
  - Adds the specified user to the docker group
- **Reasoning for Position**: It's a foundational dependency. Without Docker, the other roles that interact with containers would fail. Must be first.

#### 2. **`install_git`**

- **Function**: This role ensures that Git is installed on the target machine. Git is required to clone the application source code from a repository.
- **Key Tasks**:
  - Installs Git package via apt
- **Reasoning for Position**: It's an immediate dependency for the `clone_repo` role. You can't clone a repository if Git isn't installed. It's placed after `install_docker` because the order between these two doesn't have a strict dependency, but it's good practice to install fundamental tools first.

#### 3. **`clone_repo`**

- **Function**: This role clones the application's source code from a specified Git repository to a directory on the target host.
- **Key Tasks**:
  - Clones the GitHub repository to the specified directory
  - Checks out the specified branch (master)
  - Updates the repository if it already exists
- **Reasoning for Position**: This must run after `install_git` as it depends on Git being present. The cloned code is then used by the `backend_deployment` and `frontend_deployment` roles. The source code must be available before building Docker images.

#### 4. **`network_deployment`**

- **Function**: This role configures Docker network settings. It creates a custom bridge network that allows containers to communicate with each other using container names as hostnames.
- **Key Tasks**:
  - Creates a Docker bridge network (yolo-network)
  - Configures network driver and subnet settings
- **Reasoning for Position**: The Docker network must be created before deploying containers so that containers can be connected to the network during creation. It's placed after repository cloning because it doesn't depend on the source code, only on Docker being installed.

#### 5. **`backend_deployment`**

- **Function**: This role handles the deployment of the backend application. This involves deploying MongoDB database and building/running the Node.js Express API as Docker containers.
- **Key Tasks**:
  - Creates MongoDB volume for data persistence
  - Deploys MongoDB container
  - Creates `.env` file for backend with MongoDB connection string
  - Builds backend Docker image from source code
  - Deploys backend container with environment variables
- **Reasoning for Position**: This role depends on:
  - Docker being installed (`install_docker`)
  - Application code being available (`clone_repo`)
  - Docker network being created (`network_deployment`)
  
  The backend must be deployed before the frontend because the frontend connects to the backend API.

#### 6. **`frontend_deployment`**

- **Function**: This role deploys the frontend React application.
- **Key Tasks**:
  - Builds frontend Docker image from source code
  - Deploys frontend container
  - Connects frontend to the Docker network
  - Maps ports for external access
- **Reasoning for Position**: Similar to the backend, it depends on:
  - Docker being installed (`install_docker`)
  - Application code being available (`clone_repo`)
  - Docker network being configured (`network_deployment`)
  - Backend being available for API calls (optional but recommended)
  
  It is placed last to ensure all foundational pieces are in place before the user-facing part of the application is deployed.

---

## Ansible Modules Used

The roles utilize various Ansible modules to accomplish their tasks:

### Core System Modules
- **`ansible.builtin.apt`**: Manages apt packages (installing Docker, Git, prerequisites)
- **`ansible.builtin.apt_key`**: Manages apt repository keys (Docker GPG key)
- **`ansible.builtin.apt_repository`**: Manages apt repositories (Docker repository)
- **`ansible.builtin.systemd`**: Manages systemd services (starting Docker daemon)
- **`ansible.builtin.user`**: Manages user accounts (adding user to docker group)
- **`ansible.builtin.pip`**: Installs Python packages (Docker SDK)
- **`ansible.builtin.file`**: Manages files and directories (creating directories)
- **`ansible.builtin.copy`**: Copies files to remote hosts (.env files)
- **`ansible.builtin.template`**: Processes Jinja2 templates for configuration files

### Version Control Modules
- **`ansible.builtin.git`**: Manages git repositories (cloning the YOLO repository)

### Docker Modules
- **`community.docker.docker_network`**: Manages Docker networks (creating bridge network)
- **`community.docker.docker_volume`**: Manages Docker volumes (MongoDB data persistence)
- **`community.docker.docker_image`**: Manages Docker images (building application images)
- **`community.docker.docker_container`**: Manages Docker containers (deploying services)

### Special Modules
- **`ansible.builtin.meta`**: Performs special actions (resetting SSH connection after group changes)

---

## Variables

Variables are defined in [`ansible/group_vars/all.yml`](ansible/group_vars/all.yml) and include:

- **`app_name`**: Application name (yolo)
- **`app_user`**: System user for deployment (vagrant)
- **`app_directory`**: Application installation directory (/home/vagrant/yolo)
- **`repo_url`**: GitHub repository URL
- **`repo_branch`**: Git branch to deploy (master)
- **`docker_network_name`**: Docker network name (yolo-network)
- **`mongo_image`**: MongoDB Docker image (mongo:5.0)
- **`mongo_container_name`**: MongoDB container name (mongo)
- **`mongo_port`**: MongoDB port (27017)
- **`mongo_volume`**: MongoDB volume name (mongo-data)
- **`backend_image`**: Backend Docker image name (yolo-backend)
- **`backend_container_name`**: Backend container name (backend)
- **`backend_port`**: Backend API port (5000)
- **`backend_dir`**: Backend source directory
- **`frontend_image`**: Frontend Docker image name (yolo-client)
- **`frontend_container_name`**: Frontend container name (client)
- **`frontend_port`**: Frontend port (3000)
- **`frontend_dir`**: Frontend source directory

Sensitive variables like database credentials can be stored in [`ansible/secrets.yml`](ansible/secrets.yml) and encrypted with Ansible Vault.

---

## Deployment Flow

1. **Prerequisites Installation**: Docker and Git are installed on the target machine
2. **Source Code Acquisition**: Application repository is cloned from GitHub
3. **Network Setup**: Docker bridge network is created for inter-container communication
4. **Backend Deployment**: MongoDB and Express API containers are built and deployed
5. **Frontend Deployment**: React application container is built and deployed
6. **Verification**: Application is accessible at http://localhost:3000

---

## Benefits of This Approach

1. **Idempotency**: Ansible ensures tasks are idempotent - running the playbook multiple times produces the same result
2. **Modularity**: Roles are self-contained and reusable across different projects
3. **Consistency**: Deployment process is consistent across different environments
4. **Automation**: Manual deployment steps are eliminated
5. **Documentation**: The playbook serves as living documentation of the deployment process
6. **Scalability**: Easy to extend with additional roles or target multiple hosts
7. **Version Control**: All configuration is stored in Git for tracking and collaboration

---

## Usage

1. Start the Vagrant VM and provision with Ansible:
   ```bash
   vagrant up
   ```

2. Or provision an existing VM:
   ```bash
   vagrant provision
   ```

3. Access the application:
   - Frontend: http://localhost:3000
   - Backend API: http://localhost:5000

4. Destroy the environment:
   ```bash
   vagrant destroy
   ```

---

## Troubleshooting

- **Permission Denied**: Ensure the vagrant user has proper sudo privileges
- **Docker Connection Errors**: Verify Docker service is running and user is in docker group
- **Port Conflicts**: Check that ports 3000, 5000, and 27017 are not in use
- **Network Issues**: Ensure the Docker network is created before deploying containers
- **Build Failures**: Check that source code is properly cloned and Dockerfiles are valid

---

*This document explains the Ansible configuration management implementation for the YOLO e-commerce application deployment (IP3).*
